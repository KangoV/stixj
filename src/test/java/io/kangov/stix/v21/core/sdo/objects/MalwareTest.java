package io.kangov.stix.v21.core.sdo.objects;

import io.kangov.stix.parser.Parser;
import io.kangov.stix.util.TestBases;
import io.kangov.stix.util.TestUtils;
import io.kangov.stix.util.mock.Mocks;
import io.kangov.stix.v21.bundle.Bundleable;
import io.kangov.stix.v21.core.sco.objects.Directory;
import io.micronaut.test.extensions.junit5.annotation.MicronautTest;
import jakarta.inject.Inject;
import org.junit.jupiter.api.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static io.kangov.stix.util.TestUtils.loadResource;
import static java.util.stream.IntStream.range;
import static org.assertj.core.api.Assertions.assertThat;

@MicronautTest
public class MalwareTest extends TestBases {

    private static final Logger log = LoggerFactory.getLogger(MalwareTest.class);

    private static final Class<Malware> TYPE = Malware.class;
    private static String json;


    @Inject Mocks mock;
    @Inject Parser parser;

    @BeforeAll
    static void beforeAll() {
        json = loadResource(SDO_RESOURCES_ROOT + "malware.json");
        assertThat(json).isNotNull();
    }

    @Test
    void testRead() {
        var object = parser.read(json, TYPE);
        assertThat(object).isNotNull();
    }

    @Test
    void testWrite() {
        var object = parser.read(json, TYPE).get();
        var string = parser.write(object);
        assertThat(string).isNotNull();
    }

    @Test
    void testRandom() {
        var object = mock.mockMalware();
        range(0, MOCK_COUNT).forEach(i -> {
            var expected = mock.mockIdentity();
            var string = parser.write(expected);
            var actual = parser.read(string, Identity.class).get();
            assertThat(actual).as("(%s) -- expected json: %s", i, string).isEqualTo(expected);
        });
    }

}
